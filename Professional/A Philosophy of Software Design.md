## A Philosophy of Software Design

**Purpose For Reading**
- Highly rated, was in the book club, always looking for design perspective.
 
**Main Takeaways & Metacognition**
- Two goals:
	- Describe what complexity is and why it matters
	- Present techniques to reduce it.
- Complexity = anything that makes code hard to understand or change.
	- "If you write a piece of code and it's simple to you but complex to others, it's complex."
	- Complexity causes "Change amplification," which means you have to change code in many different places often.
	- Complexity requires more "Cognitive load," which is how much a developer needs to know in order to do something to the code.
- Basically, the most important thing you can do is try to be obvious and clean.
- Tactical vs. Strategic programming:
	- Tactical programming: Doing the least amount of work to get a job done.
		- Sometimes "pros" at this are mislabeled as heroes when all they're doing is leaving tons of technical debt behind that someone else will have to repay.
	- Strategic programming: "Working code isn't enough." Primary objective is to produce a great design that also happens to work.
		- How much to invest? Spend 10-20% on investing in good design.
- "Depth"
	- Modules (classes / services / etc) should minimize dependencies between each other. They have an interface and an implementation.
	- Interfaces should be SIMPLE. Don't show unimportant stuff. LESS IS BETTER.
	- Implementations should be 
	- 
- Much more important for code to be READABLE than easily writable.
- 

**What can I do with this?**
- What actions am I going to take based on this book, if any?

**Personal Bottom Line**
- x/10
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTA0MzY2MzI4LC01MTU1NTI4MDhdfQ==
-->